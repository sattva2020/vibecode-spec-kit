import { EventEmitter } from "events";export interface Event {type: string;payload: any;timestamp: Date;source: string;}export interface EventHandler {(event: Event): Promise<void>;}export class EventDrivenArchitecture extends EventEmitter {private eventHandlers: Map<string, EventHandler[]> = new Map();private middleware: EventMiddleware[] = [];publish(event: Event): void {this.processEvent(event).catch(error => {console.error("Error processing event:", error);});}subscribe(eventType: string, handler: EventHandler): void {if (!this.eventHandlers.has(eventType)) {this.eventHandlers.set(eventType, []);}this.eventHandlers.get(eventType)!.push(handler);}unsubscribe(eventType: string, handler: EventHandler): void {const handlers = this.eventHandlers.get(eventType);if (handlers) {const index = handlers.indexOf(handler);if (index > -1) {handlers.splice(index, 1);}}}private async processEvent(event: Event): Promise<void> {for (const middleware of this.middleware) {event = await middleware.beforeProcessing(event);}const handlers = this.eventHandlers.get(event.type) || [];await Promise.all(handlers.map(handler => handler(event)));for (const middleware of this.middleware) {await middleware.afterProcessing(event, null);}}}export interface EventMiddleware {beforeProcessing(event: Event): Promise<Event>;afterProcessing(event: Event, result: any): Promise<any>;onError(event: Event, error: Error): void;validateEvent(event: Event): boolean;}
